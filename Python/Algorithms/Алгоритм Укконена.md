Строится [[Суффиксное дерево]] для строки S длиной n, разбивая процесс на n отдельных фаз. На первой фазе он создает суффиксное дерево T1, содержащее только первый символ строки S.
На каждой последующей фазе  i (где i идет от 2 до n):
1. Алгоритм берет уже построенное суффиксное дерево Ti-1 для префикса S[1..i-1]
2. Он расширяет это дерево, добавляя i-ый символ строки S к концу всех путей в дереве.
	Существует 3 правила расширения:
	1. Продление листа
		Если путь от корня, помеченный S[j..i-1], заканчивается в листе, то символ S[i] просто добавляется в метку этого ребра.
	2. Ответвление
		Если путь заканчивается в вершине, не являющейся листом, а следующий символ отличается от **S[i]**, то создается новый лист с меткой, начинающейся с **S[i]**. Может также создаваться новая внутренняя вершина, если путь заканчивается посередине ребра.
	3. Ничего не делать.
		Если путь заканчивается в вершине, из которой есть путь по **si**, то ничего делать не надо.
1. Вместо создания новых вершин для каждого добавленного пути, алгоритм использует технику неявного суффиксного дерева.
2. Он ссылается на уже существующие вершины в Ti-1 и хранит только дополнительную информацию (индексы, ссылки) для представления новых суффиксов.
3. В результате получается неявное суффиксное дерево Ti для префикса S[1..i].

На каждом шаге алгоритм расширяет существующее дерево, избегая создания многочисленных повторяющихся вершин, благодаря использованию неявных ссылок и индексов.
После каждого расширения производится специальный проход по только что созданным внутренним вершинам для обновления их суффиксных ссылок соответствующим образом. Это позволяет поддерживать корректность структуры и гарантировать линейное общее время